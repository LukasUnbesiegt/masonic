import React, {ReactElement} from 'react'
import ResizeObserver from 'resize-observer-polyfill'
import {FreeMasonryProps, getColumns} from './index'


export class FreeMasonry extends React.Component<FreeMasonryProps> {
  itemElements: WeakMap<Element, number>
  resizeObserver: ResizeObserver
  itemPositioner: ItemPositioner
  prevRange: number[]
  prevChildren: ReactElement[]
  positionCache: PositionCache
  columnCount: number
  columnWidth: number
  columnGutter: number
  prevStartIndex: number | undefined
  prevStopIndex: number | undefined
  startIndex: number
  stopIndex: number | undefined

  constructor(props) {
    super(props)
    this.itemElements = new WeakMap()
    this.resizeObserver = new ResizeObserver(entries => {
      const updates: number[] = []

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i]

        if (entry.contentRect.height > 0) {
          const index = this.itemElements.get(entry.target),
            height = (entry.target as HTMLElement).offsetHeight,
            position = this.itemPositioner.get(index)
          if (
            position !== void 0 &&
            index !== void 0 &&
            height !== position.height
          ) {
            updates.push(index, height)
          }
        }
      }

      if (updates.length > 0) {
        this.updatePositions(updates)
      }
    })
    this.prevRange = []
    this.prevChildren = []
    this.prevStartIndex = 0
    this.initPositioner()
    this.positionCache = createPositionCache()
  }

  componentWillUnmount(): void {
    this.resizeObserver.disconnect()
  }

  componentDidUpdate(prevProps): void {
    // updates the item positions any time a value potentially affecting their size changes
    if (
      prevProps.width !== this.props.width ||
      prevProps.columnCount !== this.props.columnCount ||
      prevProps.columnWidth !== this.props.columnWidth ||
      prevProps.columnGutter !== this.props.columnGutter
    ) {
      this.repopulatePositions()
      this.forceUpdate()
    }

    // calls the onRender callback if the rendered indices changed
    if (
      typeof this.props.onRender === 'function' &&
      this.stopIndex !== void 0 &&
      (this.prevStartIndex !== this.startIndex ||
        this.prevStopIndex !== this.stopIndex)
    ) {
      this.props.onRender(this.startIndex, this.stopIndex, this.props.items)
      this.prevStartIndex = this.startIndex
      this.prevStopIndex = this.stopIndex
    }
  }

  initPositioner(p = this.props): void {
    const [columnWidth, columnCount] = getColumns(
      p.width,
      p.columnWidth || 200,
      p.columnGutter || 0,
      p.columnCount
    )
    this.columnWidth = columnWidth
    this.columnCount = columnCount
    this.columnGutter = p.columnGutter || 0
    this.itemPositioner = createItemPositioner(
      columnCount,
      columnWidth,
      p.columnGutter || 0
    )
  }

  repopulatePositions = (): void => {
    const prevPositioner = this.itemPositioner
    this.initPositioner()
    const nextPositionCache = createPositionCache()

    for (let index = 0; index < this.positionCache.getSize(); index++) {
      const pos = prevPositioner.get(index)

      if (pos !== void 0) {
        const item = this.itemPositioner.set(index, pos.height)
        nextPositionCache.setPosition(index, item.left, item.top, pos.height)
      }
    }

    this.positionCache = nextPositionCache
  }

  updatePositions = (updates: number[]): void => {
    const updatedItems = this.itemPositioner.update(updates)
    let i = 0

    for (; i < updatedItems.length - 1; i++) {
      const index = updatedItems[i],
        item = updatedItems[++i]
      this.positionCache.updatePosition(index, item.left, item.top, item.height)
    }

    this.forceUpdate()
  }

  clearPositions = (): void => {
    this.positionCache = createPositionCache()
    this.forceUpdate()
  }

  setItemRef = trieMemoize([Map], index => (el: HTMLElement): void => {
    if (this.resizeObserver !== null && el !== null) {
      if (this.itemElements.get(el) === void 0) {
        this.itemElements.set(el, index)
        this.resizeObserver.observe(el)
      }

      if (this.itemPositioner.get(index) === void 0) {
        const height = el.offsetHeight
        const item = this.itemPositioner.set(index, height)
        this.positionCache.setPosition(index, item.left, item.top, height)
      }
    }
  })

  render(): ReactElement {
    const {
      as = 'div',
      id,
      className,
      style,
      role = 'grid',
      tabIndex = 0,
      containerRef,
      items,
      itemAs = 'div',
      itemStyle,
      itemHeightEstimate = 300,
      itemKey = defaultGetItemKey,

      scrollTop,
      isScrolling,
      height,

      render,
    } = this.props
    let {overscanBy = 2} = this.props
    const itemCount = items.length,
      measuredCount = this.positionCache.getSize(),
      shortestColumnSize = this.positionCache.getShortestColumnSize()
    let children: ReactElement[] = [],
      rangeWasEqual = true
    const range: number[] = []
    overscanBy = height * overscanBy

    this.positionCache.range(
      Math.max(0, scrollTop - overscanBy),
      scrollTop + overscanBy,
      (i, l, t) => {
        range.push(i, l, t)
        const prev = this.prevRange

        if (
          rangeWasEqual &&
          (prev[range.length - 1] !== range[range.length - 1] ||
            prev[range.length - 2] !== range[range.length - 2] ||
            prev[range.length - 3] !== range[range.length - 3])
        ) {
          rangeWasEqual = false
        }
      }
    )

    if (range.length > 0) {
      if (rangeWasEqual && isScrolling && this.prevChildren.length > 0) {
        children = this.prevChildren
      } else {
        this.stopIndex = void 0

        for (let i = 0; i < range.length; i++) {
          const index = range[i],
            left = range[++i],
            top = range[++i]

          if (this.stopIndex === void 0) {
            this.startIndex = index
            this.stopIndex = index
          } else {
            this.startIndex = Math.min(this.startIndex, index)
            this.stopIndex = Math.max(this.stopIndex, index)
          }

          const data = items[index],
            key = itemKey(data, index),
            observerStyle = getCachedItemStyle(this.columnWidth, left, top)

          children.push(
            React.createElement(
              SizeObserver,
              {
                key,
                as: itemAs,
                role,
                resizeObserver: this.resizeObserver,
                observerRef: this.setItemRef(index),
                style:
                  typeof itemStyle === 'object' && itemStyle !== null
                    ? assignUserItemStyle(observerStyle, itemStyle)
                    : observerStyle,
              },
              React.createElement(render, {
                key,
                index,
                data,
                width: this.columnWidth,
              })
            )
          )
        }

        this.prevRange = range
        this.prevChildren = children
      }
    }

    if (
      shortestColumnSize < scrollTop + overscanBy &&
      measuredCount < itemCount
    ) {
      const batchSize = Math.min(
        itemCount - measuredCount,
        Math.ceil(
          ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *
          this.columnCount
        )
      )

      let index = measuredCount
      children = children === this.prevChildren ? children.slice(0) : children

      for (; index < measuredCount + batchSize; index++) {
        const data = items[index],
          key = itemKey(data, index),
          observerStyle = getCachedSize(this.columnWidth)

        children.push(
          React.createElement(
            SizeObserver,
            {
              key,
              as: itemAs,
              role,
              resizeObserver: this.resizeObserver,
              observerRef: this.setItemRef(index),
              style:
                typeof itemStyle === 'object' && itemStyle !== null
                  ? assignUserItemStyle(observerStyle, itemStyle)
                  : observerStyle,
            },
            React.createElement(render, {
              key,
              index,
              data,
              width: this.columnWidth,
            })
          )
        )
      }
    }
    // gets the container style object based upon the estimated height and whether or not
    // the page is being scrolled
    const containerStyle = getContainerStyle(
      isScrolling,
      this.positionCache.estimateTotalHeight(
        itemCount,
        this.columnCount,
        itemHeightEstimate
      )
    )

    return React.createElement(as, {
      ref: containerRef,
      id,
      role,
      className,
      tabIndex,
      style:
        typeof style === 'object' && style !== null
          ? assignUserStyle(containerStyle, style)
          : containerStyle,
      children,
    })
  }
}